# 데이터베이스

## 목차
- [Data](#데이터-data)
- [Database](#데이터베이스)
- [관계형 데이터베이스](#관계형-데이터베이스-relational-database)
- [RDBMS](#rdbms)
  - [Index](#index)
  - [Clustered Index](#clustered-index)
  - [Non-Clustered Index](#non-clustered-index)
  - [MVCC](#mvcc)
- [참고 자료](#참고-자료)

## 데이터 Data

> 저장이나 처리에 효율적인 형태로 변환된 정보

### CSV

comma-separated values로 몇 가지 필드를 쉼표로 구분한 텍스트 데이터 및 텍스트 파일이다. 일반적으로 CSV 파일은 한 응용 프로그램에서 다른 응용 프로그램으로 데이터를 전송하는 데 사용된다.


### 과거의 데이터 저장 방식
1. 파일 : 어디에서나 쉽게 사용 가능, but 데이터를 구조적으로 관리X

2. 스프레드 시트
  - 테이블의 열과 행을 사용해 데이터를 구조적으로 관리 가능(엑셀같이)

  - but, 약 100만 행까지만 저장 가능

  - 파일이나 링크 소유 여부에 따라 접근권한 설정(보안 ↓)

  - '서울'을 '서얼'로 바꾸기 위해서는 모든 '서울'을 찾아 바꿔야함(정확성 ↓)

<br>

## 데이터베이스
- 체계적인 데이터의 모음이며 데이터를 저장하고 조작함

- 데이터 조작
  - Create, 저장
  - Read, 조회
  - Update, 갱신(수정)
  - Delete, 삭제

### 분산 시스템: CAP 이론

CAP = Consistency(일관성), Availability(가용성), Partition Tolerance(분할 허용성)

- Consistency

  사용자가 분산 데이터베이스의 어떤 노드와 통신해도 같은 데이터를 조회할 수 있음을 의미한다. 데이터의 쓰기 작업이 이루어졌다면 이 데이터가 모든 복제본에 반영(동기화)하여 어떤 노드와 통신하더라도 최신 상태의 같은 데이터를 볼 수 있어야 한다.

- Availability

  모든 요청이 응답을 받을 수 있어야 함을 의미한다. 사용자가 읽기, 쓰기 작업을 하고 이것이 실패한 경우에도 사용자는 응답을 받을 수 있어야 한다. 시스템이 중단되는 일 없이 항상 사용 가능해야 하며 데이터가 일관되지 않더라도 언제든 접근할 수 있다.

- Partition Tolerance

  분할이란 노드 간의 통신이 끊어지는 것을 의미한다. 네트워크 장애나 서버 장애 등의 이유로 발생할 수 있으며 분할 허용성은 시스템 내에 분할이 발생해도 여전히 시스템이 작동하는 것이다. 이게 가능하려면 어떤 노드가 통신할 수 없을 때 다른 노드의 복제본을 통해 사용자 요청에 응답할 수 있어야 한다. 이러한 '분할 허용성'은 분산 데이터베이스 시스템에서 필수적이다.

CAP은 분산 데이터베이스 속성에 관한 이론으로 적절한 응답 시간 내에 세 가지 속성을 모두 만족시키는 분산시스템을 구성할 수 없다는 이론이다. 시스템에 분할이 생긴 경우 일관성과 가용성 중 하나를 희생해야 한다.

- CP를 만족하는 DB

  MongoDB를 예로 들면 분할이 생긴 경우 기본 노드는 액세스할 수 없는 것으로 표시되고 이를 대체할 보조 조드 중 하나가 기본노드가 되어야 한다. 이 때, 보조 노드 중 하나가 기본 노드가 될 때까지 사용자는 시스템을 사용할 수 없다. 따라서 이 경우에는 일관성 있는 시스템으로 작동하나 분할이 있는 중에는 가용성이 저하된다.

- AP를 만족하는 DB

  CassandraDB를 예로 들면 분할이 생긴 기본 노드는 다른 노드와 통신할 수 없어도 작업 수행이 가능하며 추후에 복구하여 다른 노드들과 동기화 시킨다. 이 경우에는 통신이 중단되고 다시 동기화 되기까지 일관성이 깨진 상태지만 가용성이 높다. MySQL이 여기에 속한다.


### DB 확정성
- 수평 확장(Scale-out) : 서버를 추가하여 처리 능력을 향상시키는 방법

- 수직 확장(Scale-up) : 서버에 CPU나 RAM을 추가하는 등 고성능의 부품, 서버로 교환하는 방법


### DB의 종류

- RDB : 아래 내용 참고

- NoSQL : Not Only SQL

  RDB를 보완하기 위한 데이터 저장소로 비관계형 데이터베이스이다.






<br>

## 관계형 데이터베이스 Relational Database

> 데이터 간에 `관계`가 있는 데이터 항목들의 모음
> 
> 관계 = 여러 테이블 간의 논리적 연결

### 관계형 데이터베이스의 개념
- 테이블, 행, 열의 정보를 구조화하는 방식

- 서로 관련된 데이터 포인트를 저장하고 이에 대한 액세스를 제공

- 두 테이블 사이의 관계로 인해 데이터를 다양한 형식으로 조회 가능

### 예시

<고객 테이블> id = 기본키
|`id`|  이름  |청구지|주소지|
|----|--------|-----|-----|
| `1`| 김민준 | 서울 | 강원 |
| `2`| 이서연 | 경기 | 경기 |
| `3`| 박민서 | 서울 | 서울 |

<주문 테이블> 고객ID = 외래키
|id|   주문일   |  주문상태  |`고객ID`|
|--|-----------|-----------|--------|
| 1| 2001/01/01|  배송완료  |   `3`  |
| 2| 2001/03/01|상품 준비중 |   `3`  |
| 3| 2001/02/03|   배송중   |   `1`  |

- 각 데이터에 고유한 식별값(기본키)을 부여

- 고객테이블의 정보를 참조하기 위해 주문테이블에 고객의 고유한 식별값(외래키)을 저장

- 기본키와 외래키를 이용하여 다른 데이블의 정보 참조! = 관계형 데이터베이스


### 관계형 데이터베이스 용어
1. Table(또는 relation) : 표의 형태, 데이터를 기록하는 곳

2. Field(또는 column, attribute)
  - 'id', '이름', '주소지'와 같은 데이터의 항목

  - 각 필드에는 고유한 데이터 타입 지정

3. Record(또는 row, tuple) : table에 저장되는 각각의 줄, 구체적인 데이터값이 저장됨

4. Database(또는 Schema) : 테이블의 집합

5. Primary Key(PK, 기본 키) : 각 레코드의 고유한 값, 레코드 식별자로 활용

6. Foreign Key(FK, 외래 키) : 테이블 필드 중 다른 테이블의 레코드를 식별할 수 있는 키

<br>

## RDBMS

Relational Database Management System : 관계형 데이터베이스를 관리하는 sw프로그램으로 MySQL, Oracle 등이 있다.

이는 데이터 저장 및 관리를 용이하게 하고, 데이터베이스와 사용자 간의 인터페이스 역할(데이터 구성, 업데이트, 모니터링, 백업, 복구 등을 할 수 있도록)을 한다.

특징은 아래와 같다.

1. 페이지 단위의 IO 수행하여 부분 업데이트가 가능하다.

2. Clustered Index 방식으로 데이터를 효과적으로 읽고 쓸 수 있다.

3. B+tree index를 사용하여 효율적인 레코드 검색이 가능하다.

4. soft delete, outplace-update에 가까운 복잡한 방식의 업데이트 및 삭제를 지원한다.
  - soft delete(논리 삭제)는 데이터를 실제로 삭제하지 않고 삭제 flag를 변경하는 방법으로 삭제한 데이터도 보관이 필요할 때 사용한다.
    
  - hard delete(물리 삭제)는 실제로 데이터를 삭제하는 방법이다.

5. 동시성을 높이고 transaction을 지원하기 위해 MVCC(multiversion concurrency control) 메커니즘을 사용한다.


### Index

Index는 RDBMS에서 검색 속도를 높이기 위한 기술이다. TABLE의 컬럼을 따로 파일로 저장(색인화)하여 검색 시 TABLE의 레코드를 Full scan하는 것이 아니라 해당 컬럼의 파일만 검색하여 검색(SELECT) 속도를 빠르게 한다. DELETE, INSERT, UPDATE 시에는 오히려 Index 사용 시 느려진다.

#### B+Tree 알고리즘

B+tree는 Index 자료구조인 B-tree(Balanced Tree)의 확장된 개념이다.

![B-tree](./image/B-tree.png)

B-tree는 데이터가 정렬된 상태를 유지하며, 이진트리를 확장하여 N개의 자식을 가질 수 있다.

가장 상단의 Root Node(1개 존재), 중간 노드인 Branch Node, 최하위 노드인 Leaf Node로 이루어져 있다. 그리고 좌우 자식 간의 depth 균형이 맞지 않을 경우 비효율적이므로 B-tree는 균형 트리이다.

인덱스 키를 바탕으로 항상 정렬된 상태를 유지하며 정렬된 인덱스 키를 따라 리프 노드에 도달 시 (index key, PK)쌍으로 저장되어 있다. 이렇게 찾은 PK로 레코드를 조회한다. 이러한 방식으로 key 값으로 데이터를 찾기 때문에 Full scan에 비해 검색 속도가 빠르다.

![B+tree](./image/B+tree.png)

B-tree는 branch에 key와 data를 둘 다 담는데 이와 다르게 B+tree는 branch node에 key만 담고, leaf node만이 key와 data를 모두 담는다. leaf node끼리는 linked list로 연결되어 있다.

이러한 특징으로 인한 장점은 아래와 같다.

1. 리프노드를 제외하고는 데이터를 담지 않기 때문에 메모리를 확보하여 더 많은 key를 수용할 수 있다(=트리의 높이가 낮아진다).
2. Full scan 시 B-tree는 모든 노드를 확인해야 하지만 B+tree는 leaf node에 모든 데이터가 있어 한 번의 선형탐색만 하면 되기 때문에 더 빠르다.


### Clustered Index

TABLE의 레코드를 지정된 컬럼을 기준으로 물리적 재배열하며 데이터 삽입, 수정, 삭제 시에도 데이터를 정렬한다. Clustered Index는 테이블 당 한 개만 존재 가능하기 때문에 테이블에서 Index를 걸면 가장 효율적인 컬럼을 Clustered Index로 지정한다.

Clustered Index는 데이터를 해당 컬럼으로 정렬한 후 루트 페이지를 만들고 루트 페이지와 리프 페이지로 구성되며 리프 페이지는 데이터 그 자체이다. 물리적으로 정렬되어 있기 때문에 검색 속도는 Non-Clustered Index보다 빠르나 삽입, 수정, 삭제 시에도 정렬을 수행하기 때문의 삽입, 수정, 삭제 속도는 더 느리다.


### Non-Clustered Index

Non-Clustered Index는 물리적으로 데이터를 배열하지 않은 상태로 지정된 컬럼에 대해 정렬시킨 인덱스만 만든다. 그러므로 테이블 당 여러 개 존재 가능하다.


### MVCC

Multi-Version Concurrency Control : 다중 버전 동시성 제어

#### 동시성 제어

DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜젝션의 상호간섭 작용에서 DB를 보호하는 것을 의미한다. 동시성 제어를 할 수 있도록 Lock 기능, `SET TRANSACTION`를 이용하여 격리성 수준을 조정할 수 있는 기능이 있고, 낙관적 동시성 제어와 비관적 동시성 제어 방법이 있다.

1. 낙관적 동시성 제어
  - 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
  - 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경되었는지를 반드시 검사

2. 비관적 동시성 제어
  - 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
  - 데이터를 읽는 시점에 Lock을 걸고 트랜젝션이 완료될 때까지 Lock 유지

*Lock : 비관적 동시성 제어를 위한 방법으로 공유락(Shared Lock)-읽기 잠금, 베타락(Exclusive Lock)-쓰기 잠금이 있다.

Lock은 읽기 작업과 쓰기 작업에 서로 방해를 일으키기 때문에 동시성 문제가 발생할 수 있고, 데이터 일관성 문제로 Lock을 더 오래 유지하는 경우 동시성 저하가 발행한다. 이러한 문제점을 해결하기 위해 MVCC가 나왔다.

#### 다중 버전 동시성 제어

MVCC에서 데이터에 접근하는 사용자는 접근한 시점에 데이터베이스의 Snapshot을 읽고, 이 snapshot 데이터에 대한 변경이 commit될 때 까지의 변경사항은 다른 사용자가 볼 수 없다. 이후 commit하면 데이터를 덮어씌우는 것이 아니라 새로운 버전의 데이터를 이전 버전과 비교하여 변경된 내용을 기록한다. 이렇게 여러 버전의 데이터가 존재하며 사용자는 마지막 버전의 데이터를 읽게 된다. (git과 굉장히 유사하다고 느꼈다) 특징은 아래와 같다.

- Lock이 필요하지 않기 때문에 매우 빠르다.

- 사용하지 않는 데이터가 계속 쌓이므로 데이터를 정리하는 시스템이 필요하다.

- 데이터 버전이 충돌하면 애플리케이션 영역에서 문제를 해결해야 한다.


<br>

## 참고 자료

https://velog.io/@taeha7b/hard-delete-softdelete

https://velog.io/@gillog/SQL-Index%EC%9D%B8%EB%8D%B1%EC%8A%A4

https://zorba91.tistory.com/293

https://mangkyu.tistory.com/286

https://velog.io/@gillog/SQL-Clustered-Index-Non-Clustered-Index

https://mangkyu.tistory.com/53

https://onduway.tistory.com/106

https://devuna.tistory.com/73

https://www.oracle.com/kr/database/nosql/what-is-nosql/
